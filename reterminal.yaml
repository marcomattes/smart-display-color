esphome:
  name: reterminal
  friendly_name: reTerminal

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# Deep Sleep für maximale Batterielaufzeit - TEMPORÄR DEAKTIVIERT FÜR OTA UPDATE
# Wacht auf durch: Buttons (GPIO3/5/6) oder nach sleep_duration
# deep_sleep:
#   id: deep_sleep_control
#   # Nach 5 Minuten Aktivität schlafen gehen (länger als vorher für Stabilität)
#   run_duration: 5min
#   # 10 Minuten schlafen (kürzer für häufigere Updates)
#   sleep_duration: 10min
#   # ESP32-S3 spezifische Einstellungen - mehrere Wakeup-Pins
#   esp32_ext1_wakeup:
#     pins:
#       - number: GPIO3
#         allow_other_uses: true
#       - number: GPIO6
#         allow_other_uses: true
#       - number: GPIO5
#         allow_other_uses: true
#     mode: ANY_HIGH

# Enable logging
logger:
  level: INFO
  logs:
    sensor: INFO
    sht4x: WARN
    adc: WARN
    # Optional: Uncomment for SD card logging when implemented
    # baud_rate: 0  # Disable UART logging if using GPIO1/3 for other purposes

# Enable Home Assistant API
api:
  encryption:
    key: "KFpc9eNW6iKqsr1zPPY3JhldWkrLiEMXpq71EJHwlug="

ota:
  - platform: esphome
    password: "57e1f7adc1238c1b4a41203d0286cf45"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Reterminal Fallback Hotspot"
    password: "RKo654k6a1EU"


captive_portal:

# Bluetooth proxy configuration - DEAKTIVIERT für Debugging
# Kann Bootloops auf ESP32-S3 verursachen
# esp32_ble_tracker:
#   scan_parameters:
#     interval: 1100ms
#     window: 1100ms
#     active: true

# bluetooth_proxy:
#   active: true
#   id: bt_proxy

# HTTP Request für Web-Bilder (für Online-Image-Download)
http_request:
  useragent: esphome/device
  timeout: 10s

# Online Image - Dynamisch geladenes Gast-WLAN QR Code
online_image:
  - url: "https://assistant.mattes.app/api/image_proxy/image.mhome_mkm_gast?token=7630835437efed90878cb9084d160958cc6d487bbfe750340ad3b7549a118589&state=2025-10-31T18:36:27.645086+00:00"
    id: guest_wifi_qr
    format: PNG
    type: BINARY
    resize: 200x200
    update_interval: never
    on_download_finished:
      then:
        - logger.log: "QR Code erfolgreich heruntergeladen"
        - component.update: epaper_display
    on_error:
      then:
        - logger.log: 
            format: "Fehler beim Laden des QR Codes"
            level: ERROR

# define fonts for different sizes
font:
  - file: "gfonts://Inter@700"
    id: inter_large
    size: 36
  - file: "gfonts://Inter@400"
    id: inter_medium
    size: 24
  - file: "gfonts://Inter@300"
    id: inter_small
    size: 18

# Define colors as globals
color:
  - id: display_red
    red: 100%
    green: 0%
    blue: 0%
  - id: display_black
    red: 0%
    green: 0%
    blue: 0%
  - id: display_blue
    red: 0%
    green: 0%
    blue: 100%

# Home Assistant Sensoren für echte Daten
sensor:
  # Außentemperatur
  - platform: homeassistant
    name: "Outside Temperature"
    id: outside_temp
    entity_id: sensor.marcos_reich_aussentemperatur

  # Luftqualität PM2.5
  - platform: homeassistant
    name: "Air Quality PM2.5"
    id: air_quality_pm25
    entity_id: sensor.luftreiniger_pm2_5

  # 3D Drucker - Düsentemperatur
  - platform: homeassistant
    name: "3D Printer Nozzle Temp"
    id: printer_nozzle_temp
    entity_id: sensor.bambulab_drucker_temperatur_der_duse

  # 3D Drucker - Druckbett Temperatur
  - platform: homeassistant
    name: "3D Printer Bed Temp"
    id: printer_bed_temp
    entity_id: sensor.bambulab_drucker_druckbetttemperatur

  # Wohnzimmer Luftfeuchtigkeit
  - platform: homeassistant
    name: "Living Room Humidity"
    id: living_room_humidity
    entity_id: sensor.wohnzimmer_luftfeuchtigkeit

  # Wohnzimmer Temperatur
  - platform: homeassistant
    name: "Living Room Temperature"
    id: living_room_temp
    entity_id: sensor.wohnzimmer_temperatur

  # Sonnenaufgang (nächster Sonnenaufgang) - DEAKTIVIERT
  # - platform: homeassistant
  #   name: "Sun Next Rising"
  #   id: sun_next_rising
  #   entity_id: sensor.sun_next_rising
    
  # Local System Memory (ESPHome internal)
  - platform: template
    name: "System Memory Usage"
    id: sys_memory
    lambda: |-
      return heap_caps_get_free_size(MALLOC_CAP_INTERNAL) * 100.0 / heap_caps_get_total_size(MALLOC_CAP_INTERNAL);
    unit_of_measurement: "%"
    update_interval: 60s
    
  # Uptime
  - platform: uptime
    name: "Device Uptime"
    id: sys_uptime

  # WiFi Signal Strength
  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_rssi
    update_interval: 60s

  # Bluetooth proxy status - DEAKTIVIERT
  # - platform: ble_rssi
  #   mac_address: "00:00:00:00:00:00"
  #   name: "BLE Signal Strength"
  #   id: bluetooth_rssi
  #   internal: true

  # Battery Voltage (via ADC) - Korrekte reTerminal Hardware
  - platform: adc
    pin: GPIO1
    name: "Battery Voltage Raw"
    id: battery_voltage_raw
    attenuation: 12db
    update_interval: 60s
    internal: true



  # Battery Percentage (calculated from voltage)
  - platform: template
    name: "Battery Level"
    id: battery_level
    lambda: |-
      // Typische Li-Ion Batterie Spannungen:
      // 4.2V = 100%, 3.7V = 50%, 3.0V = 0%
      if (id(battery_voltage_raw).has_state()) {
        float voltage = id(battery_voltage_raw).state;
        // Voltage divider angepasst (reTerminal hat normalerweise einen Spannungsteiler)
        voltage = voltage * 2.0; // Anpassen je nach Hardware
        
        if (voltage >= 4.1) return 100.0;
        if (voltage <= 3.0) return 0.0;
        
        // Linear interpolation zwischen 3.0V (0%) und 4.1V (100%)
        return ((voltage - 3.0) / (4.1 - 3.0)) * 100.0;
      }
      return 0.0;
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: 60s

  # Power consumption estimate (reTerminal spezifisch)
  - platform: template
    name: "Power Consumption"
    id: power_consumption
    lambda: |-
      // reTerminal ESP32-S3 Stromverbrauch (2000mAh @ 3.7V)
      float base_power = 0.3; // ESP32-S3 base consumption
      
      // E-Ink 7.3" Display (nur beim Update aktiv)
      base_power += 0.05; // Standby sehr niedrig
      
      // Bluetooth wenn aktiv - DEAKTIVIERT
      // if (id(bluetooth_status).has_state() && id(bluetooth_status).state == "Active") {
      //   base_power += 0.2;
      // }
      
      // WiFi
      if (id(wifi_ssid).has_state()) {
        base_power += 0.3;
      }
      
      return base_power;
    unit_of_measurement: "W"
    accuracy_decimals: 2
    update_interval: 300s

  # Hardware SHT40 Temperatur/Feuchtigkeit Sensor
  - platform: sht4x
    i2c_id: bus_a
    temperature:
      name: "Internal Temperature"
      id: internal_temp
    humidity:
      name: "Internal Humidity" 
      id: internal_humidity
    update_interval: 60s

# I2C Bus für Hardware-Sensoren
i2c:
  sda: GPIO19
  scl: GPIO20
  scan: true
  id: bus_a

# Zeit-Sensoren für lokale Zeit
time:
  - platform: homeassistant
    id: homeassistant_time
  
  # Hardware RTC (PCF8563) für Zeit ohne WiFi - Fallback
  - platform: pcf8563
    id: rtc_time
    address: 0x51
    i2c_id: bus_a
    # Sync RTC with Home Assistant time
    on_time_sync:
      - logger.log: "RTC synced with network time"

text_sensor:
  # Einkaufsliste Count
  - platform: homeassistant
    name: "Shopping List Count"
    id: shopping_list_count
    entity_id: todo.einkaufsliste

  # Media Player - Now Playing
  - platform: homeassistant
    name: "Now Playing Title"
    id: now_playing_title
    entity_id: media_player.studio
    attribute: media_title

  - platform: homeassistant
    name: "Now Playing Artist"
    id: now_playing_artist
    entity_id: media_player.studio
    attribute: media_artist

  # Zeit und Datum als Text-Sensoren
  - platform: template
    name: "Current Time"
    id: current_time
    lambda: |-
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) {
        return {"--:--"};
      }
      return {time.strftime("%H:%M").c_str()};
    update_interval: 30s
    
  - platform: template
    name: "Current Date" 
    id: current_date
    lambda: |-
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) {
        return {"Warte auf Zeit..."};
      }
      return {time.strftime("%d.%m.%Y").c_str()};
    update_interval: 300s
    
  # WiFi Status (lokale ESPHome Sensoren)
  - platform: wifi_info
    ssid:
      name: "WiFi SSID"
      id: wifi_ssid
    ip_address:
      name: "IP Address"
      id: wifi_ip_local
      
  # IP Address von Home Assistant - DEAKTIVIERT (nutze lokale IP)
  # - platform: homeassistant
  #   name: "IP Address"
  #   id: wifi_ip
  #   entity_id: sensor.reterminal_ip_address
      
  # Home Assistant Connection Status - DEAKTIVIERT
  # - platform: homeassistant
  #   name: "HA Connection"
  #   id: ha_connection
  #   entity_id: binary_sensor.reterminal_api
  
  # HA Connection Status (Template)
  - platform: template
    name: "HA Connection"
    id: ha_connection
    lambda: |-
      if (api::global_api_server->is_connected()) {
        return {"Connected"};
      }
      return {"Disconnected"};
    update_interval: 10s
    
  # Wetter Status (passe entity_id an) - DEAKTIVIERT
  # - platform: homeassistant
  #   name: "Weather Status"
  #   id: weather_status
  #   entity_id: weather.home
    
  # Bluetooth proxy status - DEAKTIVIERT
  # - platform: template
  #   name: "Bluetooth Status"
  #   id: bluetooth_status
  #   lambda: |-
  #     if (id(bt_proxy)->has_active()) {
  #       return {"Active"};
  #     }
  #     return {"Inactive"};
  #   update_interval: 60s
    
  # Last button pressed
  - platform: template
    name: "Last Button"
    id: last_button
    lambda: |-
      return {"Ready"};
    update_interval: never
    
  # Battery Status Text
  - platform: template
    name: "Battery Status"
    id: battery_status
    lambda: |-
      if (id(battery_level).has_state()) {
        float level = id(battery_level).state;
        if (level > 80) return {"Excellent"};
        if (level > 60) return {"Good"};
        if (level > 40) return {"Fair"};
        if (level > 20) return {"Low"};
        if (level > 5) return {"Critical"};
        return {"Empty"};
      }
      return {"Unknown"};
    update_interval: 60s
    
  # Estimated Runtime
  - platform: template
    name: "Battery Runtime"
    id: battery_runtime
    lambda: |-
      if (id(battery_level).has_state() && id(power_consumption).has_state()) {
        float level = id(battery_level).state;
        float power = id(power_consumption).state;
        
        // reTerminal Batteriekapazität: 2000mAh @ 3.7V = ~7.4Wh
        float capacity_wh = 7.4;
        float remaining_wh = capacity_wh * (level / 100.0);
        
        if (power > 0.1) {
          float hours = remaining_wh / power;
          if (hours > 24) {
            return {(std::to_string((int)(hours / 24)) + "d " + std::to_string((int)hours % 24) + "h").c_str()};
          } else if (hours > 1) {
            return {(std::to_string((int)hours) + "h " + std::to_string((int)((hours - (int)hours) * 60)) + "m").c_str()};
          } else {
            return {(std::to_string((int)(hours * 60)) + " min").c_str()};
          }
        }
      }
      return {"N/A"};
    update_interval: 300s

# Binary sensors for buttons
binary_sensor:
  # Fenster Status von Home Assistant
  - platform: homeassistant
    name: "Living Room Window"
    id: living_room_window
    entity_id: binary_sensor.wohnzimmer_fenster

  - platform: homeassistant
    name: "Kitchen Window"
    id: kitchen_window
    entity_id: binary_sensor.kuche_fenster

  - platform: homeassistant
    name: "Bedroom Window"
    id: bedroom_window
    entity_id: binary_sensor.schlafzimmer_fenster

  - platform: homeassistant
    name: "Bathroom Window"
    id: bathroom_window
    entity_id: binary_sensor.badezimmer_fenster

  # Button 1 - Refresh Display (KEY0)
  - platform: gpio
    pin:
      number: GPIO3
      mode: INPUT_PULLUP
      inverted: true
      allow_other_uses: true
      ignore_strapping_warning: true
    name: "Button 1 - Refresh"
    id: button1_refresh
    on_press:
      then:
        - logger.log: "Button 1 pressed - Refreshing display and QR code"
        - text_sensor.template.publish:
            id: last_button
            state: "Refresh (B1)"
        - script.execute: beep_short
        - component.update: guest_wifi_qr
        - component.update: epaper_display

  # Button 2 - Force Update Sensors (KEY1)
  - platform: gpio
    pin:
      number: GPIO6
      mode: INPUT_PULLUP
      inverted: true
      allow_other_uses: true
    name: "Button 2 - Update Sensors"
    id: button2_update
    on_press:
      then:
        - logger.log: "Button 2 pressed - Updating sensors"
        - text_sensor.template.publish:
            id: last_button
            state: "Update (B2)"
        - script.execute: beep_short
        - component.update: sys_memory
        - component.update: current_time
        - component.update: current_date
        - delay: 2s
        - component.update: epaper_display

  # Button 3 - System Info (KEY2)
  - platform: gpio
    pin:
      number: GPIO5
      mode: INPUT_PULLUP
      inverted: true
      allow_other_uses: true
    name: "Button 3 - System Info"
    id: button3_info
    on_press:
      then:
        - logger.log: "Button 3 pressed - System info logged"
        - text_sensor.template.publish:
            id: last_button
            state: "Info (B3)"
        - script.execute: beep_double
        - logger.log: 
            format: "System Status - Memory: %.1f%%, Uptime: %.1fh, Temp: %.1f°C"
            args: 
              - id(sys_memory).state
              - 'id(sys_uptime).state / 3600.0'
              - id(internal_temp).state
  
  # microSD Card Detect
  - platform: gpio
    pin:
      number: GPIO15
      mode: INPUT_PULLUP
    name: "SD Card Detected"
    id: sd_card_detect
    device_class: presence

# Battery monitoring control
switch:
  - platform: gpio
    pin: GPIO21
    name: "Battery Monitor Enable"
    id: battery_monitor_enable
    restore_mode: RESTORE_DEFAULT_ON
    internal: true
  
  # microSD Card Power Enable
  - platform: gpio
    pin: GPIO16
    name: "SD Card Enable"
    id: sd_enable
    restore_mode: RESTORE_DEFAULT_ON
    internal: true
  
  # Buzzer (Active Buzzer via Transistor on GPIO45)
  - platform: gpio
    pin:
      number: GPIO45
      mode: OUTPUT
      inverted: false  # Try false first, flip to true if no sound
      ignore_strapping_warning: true
    id: buzzer_sw
    internal: true
    name: "Buzzer Enable"
  
  # PDM Microphone Enable
  - platform: gpio
    pin: GPIO38
    name: "Microphone Enable"
    id: mic_enable
    restore_mode: RESTORE_DEFAULT_OFF
    internal: true

# Buzzer Script für einfache Beeps
script:
  - id: beep_short
    mode: restart
    then:
      - switch.turn_on: buzzer_sw
      - delay: 200ms
      - switch.turn_off: buzzer_sw
  
  - id: beep_double
    mode: restart
    then:
      - switch.turn_on: buzzer_sw
      - delay: 100ms
      - switch.turn_off: buzzer_sw
      - delay: 100ms
      - switch.turn_on: buzzer_sw
      - delay: 100ms
      - switch.turn_off: buzzer_sw

# define SPI interface
spi:
  clk_pin: GPIO7
  mosi_pin: GPIO9
  miso_pin: GPIO8  # Für microSD Card

# Automation für Init beim Boot
interval:
  - interval: 30s
    then:
      - if:
          condition:
            lambda: 'return id(sys_uptime).state < 60;'
          then:
            - logger.log: "Initial boot - updating all sensors and QR code"
            - component.update: sys_memory
            - component.update: current_time
            - component.update: current_date
            - component.update: battery_voltage_raw
            - component.update: guest_wifi_qr
            - delay: 5s
            - component.update: epaper_display

display:
  - platform: epaper_spi
    id: epaper_display
    model: 7.3in-spectra-e6
    cs_pin: GPIO10
    dc_pin: GPIO11
    reset_pin:
      number: GPIO12
      inverted: false
    busy_pin:
      number: GPIO13
      inverted: true
    update_interval: 3min
    pages:
      - id: main_page
        lambda: |-
          // Layout-Hilfsfunktion für umrandete Bereiche
          auto draw_bordered_area = [&](int x, int y, int w, int h, const char* title) {
            // Roter Rahmen (4px)
            it.rectangle(x, y, w, h, id(display_red));
            it.rectangle(x+1, y+1, w-2, h-2, id(display_red));
            it.rectangle(x+2, y+2, w-4, h-4, id(display_red));
            it.rectangle(x+3, y+3, w-6, h-6, id(display_red));
            
            // Titel
            if (title && strlen(title) > 0) {
              it.print(x + 10, y + 15, id(inter_medium), id(display_black), title);
            }
          };
          
          // Layout-Konstanten
          const int MARGIN = 10;
          const int SPACING = 8;
          
          int width = it.get_width();
          int height = it.get_height();
          
          // Badge Area ganz oben (20% der Höhe)
          int badge_height = height * 0.2;
          int badge_width = width - 2*MARGIN;
          draw_bordered_area(MARGIN, MARGIN, badge_width, badge_height, "System Status");
          
          // Badge Inhalt - System-Info zentriert
          it.printf(width/2, MARGIN + badge_height/2 - 10, id(inter_large), id(display_black), 
                   TextAlign::CENTER, "reTerminal Display");
          it.printf(width/2, MARGIN + badge_height/2 + 20, id(inter_small), id(display_blue), 
                   TextAlign::CENTER, "HA: %s | ESPHome", 
                   id(ha_connection).has_state() ? id(ha_connection).state.c_str() : "N/A");
          
          // Grid-Bereich (80% der verbleibenden Höhe)
          int grid_start_y = MARGIN + badge_height + SPACING;
          int grid_height = height - grid_start_y - MARGIN;
          int grid_width = width - 2*MARGIN;
          
          // Linke Spalte (50% Breite)
          int left_width = grid_width / 2 - SPACING/2;
          
          // Rechte Spalte (50% Breite) - Service Status (volle Höhe)
          int right_width = grid_width / 2 - SPACING/2;
          int right_x = MARGIN + left_width + SPACING;
          draw_bordered_area(right_x, grid_start_y, right_width, grid_height, "Service Status");
          
          // Service Status Inhalt - System Info
          it.printf(right_x + 15, grid_start_y + 35, id(inter_small), id(display_blue), "SYSTEM");
          it.printf(right_x + 15, grid_start_y + 55, id(inter_small), id(display_black),
                   "WiFi: %s", id(wifi_ssid).has_state() ? id(wifi_ssid).state.c_str() : "N/A");
          it.printf(right_x + 15, grid_start_y + 75, id(inter_small), id(display_black),
                   "HA: %s | Mem: %.0f%%",
                   id(ha_connection).has_state() ? id(ha_connection).state.c_str() : "N/A",
                   id(sys_memory).has_state() ? id(sys_memory).state : 0.0f);

          // Environment Info
          it.printf(right_x + 15, grid_start_y + 105, id(inter_small), id(display_blue), "ENVIRONMENT");
          it.printf(right_x + 15, grid_start_y + 125, id(inter_small), id(display_black),
                   "Inside: %.1f°C | %.0f%%",
                   id(internal_temp).has_state() ? id(internal_temp).state : 0.0f,
                   id(internal_humidity).has_state() ? id(internal_humidity).state : 0.0f);
          it.printf(right_x + 15, grid_start_y + 145, id(inter_small), id(display_black),
                   "Outside: %.1f°C",
                   id(outside_temp).has_state() ? id(outside_temp).state : 0.0f);
          it.printf(right_x + 15, grid_start_y + 165, id(inter_small), id(display_black),
                   "Living: %.1f°C | %.0f%%",
                   id(living_room_temp).has_state() ? id(living_room_temp).state : 0.0f,
                   id(living_room_humidity).has_state() ? id(living_room_humidity).state : 0.0f);
          it.printf(right_x + 15, grid_start_y + 185, id(inter_small), id(display_black),
                   "Air Quality: %.0f µg/m³",
                   id(air_quality_pm25).has_state() ? id(air_quality_pm25).state : 0.0f);

          // Smart Home Status
          it.printf(right_x + 15, grid_start_y + 215, id(inter_small), id(display_blue), "WINDOWS");
          it.printf(right_x + 15, grid_start_y + 235, id(inter_small), id(display_black),
                   "Living: %s | Kitchen: %s",
                   id(living_room_window).has_state() && id(living_room_window).state ? "OPEN" : "CLOSED",
                   id(kitchen_window).has_state() && id(kitchen_window).state ? "OPEN" : "CLOSED");
          it.printf(right_x + 15, grid_start_y + 255, id(inter_small), id(display_black),
                   "Bed: %s | Bath: %s",
                   id(bedroom_window).has_state() && id(bedroom_window).state ? "OPEN" : "CLOSED",
                   id(bathroom_window).has_state() && id(bathroom_window).state ? "OPEN" : "CLOSED");

          // 3D Printer Status
          it.printf(right_x + 15, grid_start_y + 285, id(inter_small), id(display_blue), "3D PRINTER");
          it.printf(right_x + 15, grid_start_y + 305, id(inter_small), id(display_black),
                   "Nozzle: %.0f°C | Bed: %.0f°C",
                   id(printer_nozzle_temp).has_state() ? id(printer_nozzle_temp).state : 0.0f,
                   id(printer_bed_temp).has_state() ? id(printer_bed_temp).state : 0.0f);

          // Now Playing
          if (id(now_playing_title).has_state() && id(now_playing_artist).has_state()) {
            it.printf(right_x + 15, grid_start_y + 335, id(inter_small), id(display_blue), "NOW PLAYING");
            it.printf(right_x + 15, grid_start_y + 355, id(inter_small), id(display_black),
                     "%s", id(now_playing_title).state.c_str());
            it.printf(right_x + 15, grid_start_y + 375, id(inter_small), id(display_black),
                     "%s", id(now_playing_artist).state.c_str());
          }
          
          // Linke Spalte - aufgeteilt in 3 Bereiche
          int left_section_height = grid_height / 3;
          
          // Datum und Uhrzeit (obere Hälfte der linken Spalte)
          draw_bordered_area(MARGIN, grid_start_y, left_width, left_section_height, "Datum & Uhrzeit");
          
          // Aktuelle Zeit und Datum von Home Assistant
          it.printf(MARGIN + left_width/2, grid_start_y + 60, id(inter_large), id(display_black), 
                   TextAlign::CENTER, "%s", 
                   id(current_time).has_state() ? id(current_time).state.c_str() : "--:--");
          it.printf(MARGIN + left_width/2, grid_start_y + 100, id(inter_medium), id(display_blue), 
                   TextAlign::CENTER, "%s", 
                   id(current_date).has_state() ? id(current_date).state.c_str() : "Datum nicht verfügbar");
          
          // Batterie & Shopping List (mittlere Sektion der linken Spalte)
          int middle_y = grid_start_y + left_section_height + SPACING;
          draw_bordered_area(MARGIN, middle_y, left_width, left_section_height - SPACING, "Batterie & To-Do");

          // Batterie-Informationen (kompakt)
          it.printf(MARGIN + left_width/2, middle_y + 25, id(inter_medium), id(display_blue),
                   TextAlign::CENTER, "%.0f%% - %s",
                   id(battery_level).has_state() ? id(battery_level).state : 0.0f,
                   id(battery_status).has_state() ? id(battery_status).state.c_str() : "Unknown");
          it.printf(MARGIN + left_width/2, middle_y + 50, id(inter_small), id(display_black),
                   TextAlign::CENTER, "Runtime: %s",
                   id(battery_runtime).has_state() ? id(battery_runtime).state.c_str() : "N/A");

          // Shopping List
          it.printf(MARGIN + left_width/2, middle_y + 80, id(inter_small), id(display_blue),
                   TextAlign::CENTER, "EINKAUFSLISTE");
          it.printf(MARGIN + left_width/2, middle_y + 105, id(inter_large), id(display_black),
                   TextAlign::CENTER, "%s",
                   id(shopping_list_count).has_state() ? id(shopping_list_count).state.c_str() : "0");
          it.printf(MARGIN + left_width/2, middle_y + 130, id(inter_small), id(display_black),
                   TextAlign::CENTER, "Items");
          
          // Gast WLAN QR Code Bereich (untere Sektion der linken Spalte)
          int tools_y = grid_start_y + 2*(left_section_height) + SPACING;
          draw_bordered_area(MARGIN, tools_y, left_width, left_section_height - SPACING, "Gast WLAN");
          
          // QR Code zentriert anzeigen
          int qr_size = 200;  // Resize auf 200x200
          int qr_x = MARGIN + (left_width - qr_size) / 2;
          int qr_y = tools_y + 35;
          
          // Online Image wird immer versucht anzuzeigen, wenn verfügbar
          it.image(qr_x, qr_y, id(guest_wifi_qr), COLOR_ON, COLOR_OFF);    