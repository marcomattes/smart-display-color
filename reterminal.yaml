esphome:
  name: reterminal
  friendly_name: reTerminal

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_MBEDTLS_CERTIFICATE_BUNDLE: n
      CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL: n

# Enable logging
logger:
  level: DEBUG
  logs:
    text_sensor: DEBUG
    homeassistant.text_sensor: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: "KFpc9eNW6iKqsr1zPPY3JhldWkrLiEMXpq71EJHwlug="
  on_client_connected:
    then:
      - logger.log: "Home Assistant connected"
      - delay: 15s
      - logger.log: "Waiting for sensors to receive data..."
      - component.update: epaper_display
  on_client_disconnected:
    then:
      - logger.log: "Home Assistant disconnected"

ota:
  - platform: esphome
    password: "57e1f7adc1238c1b4a41203d0286cf45"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Reterminal Fallback Hotspot"
    password: "RKo654k6a1EU"

captive_portal:

# Fonts - Noto Sans mit vollstÃ¤ndiger deutscher ZeichenunterstÃ¼tzung
font:
  - file: "gfonts://Noto Sans@700"
    id: inter_large
    size: 42
  - file: "gfonts://Noto Sans@500"
    id: inter_medium
    size: 28
  - file: "gfonts://Noto Sans@400"
    id: inter_small
    size: 22

# Colors
color:
  - id: display_red
    red: 100%
    green: 0%
    blue: 0%
  - id: display_black
    red: 0%
    green: 0%
    blue: 0%
  - id: display_blue
    red: 0%
    green: 0%
    blue: 100%
  - id: display_white
    red: 100%
    green: 100%
    blue: 100%
  - id: display_green
    red: 0%
    green: 100%
    blue: 0%
  - id: display_gray
    red: 60%
    green: 60%
    blue: 60%

# I2C Bus
i2c:
  sda: GPIO19
  scl: GPIO20
  scan: true
  id: bus_a

# Time
time:
  - platform: homeassistant
    id: homeassistant_time

# Sensors
sensor:
  # Battery Voltage (via ADC)
  - platform: adc
    pin: GPIO1
    name: "Battery Voltage Raw"
    id: battery_voltage_raw
    attenuation: 12db
    update_interval: 60s
    internal: true

  # Battery Percentage
  - platform: template
    name: "Battery Level"
    id: battery_level
    lambda: |-
      if (id(battery_voltage_raw).has_state()) {
        float voltage = id(battery_voltage_raw).state;
        voltage = voltage * 2.0;

        if (voltage >= 4.1) return 100.0;
        if (voltage <= 3.0) return 0.0;

        return ((voltage - 3.0) / (4.1 - 3.0)) * 100.0;
      }
      return 0.0;
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: 60s

# Text Sensors
text_sensor:
  # Calendar Events from Home Assistant Template Sensor
  - platform: homeassistant
    name: "Calendar Events"
    id: calendar_events
    entity_id: sensor.display_calendar_events

  # Shopping List Items from Home Assistant Template Sensor
  - platform: homeassistant
    name: "Shopping List Items"
    id: shopping_list_items
    entity_id: sensor.display_shopping_list_items

  # Current Date
  - platform: template
    name: "Current Date"
    id: current_date
    lambda: |-
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) {
        return {"Warte auf Zeit..."};
      }
      return {time.strftime("%A, %d. %B %Y").c_str()};
    update_interval: 300s

  # Current Time
  - platform: template
    name: "Current Time"
    id: current_time
    lambda: |-
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) {
        return {"--:--"};
      }
      return {time.strftime("%H:%M").c_str()};
    update_interval: 30s

# Binary Sensors for Buttons
binary_sensor:
  # Button 1 - Refresh Display
  - platform: gpio
    pin:
      number: GPIO3
      mode: INPUT_PULLUP
      inverted: true
      ignore_strapping_warning: true
    name: "Button 1 - Refresh"
    id: button1_refresh
    on_press:
      then:
        - logger.log: "Button 1 pressed - Refreshing display"
        - script.execute: beep_short
        - component.update: epaper_display

  # Button 2 - Update Sensors
  - platform: gpio
    pin:
      number: GPIO6
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 2 - Update Sensors"
    id: button2_update
    on_press:
      then:
        - logger.log: "Button 2 pressed - Updating sensors"
        - script.execute: beep_short
        - component.update: current_time
        - component.update: current_date
        - delay: 2s
        - component.update: epaper_display

  # Button 3 - System Info
  - platform: gpio
    pin:
      number: GPIO5
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 3 - System Info"
    id: button3_info
    on_press:
      then:
        - logger.log: "Button 3 pressed - System info logged"
        - script.execute: beep_double

# Switches
switch:
  # Battery Monitor Enable
  - platform: gpio
    pin: GPIO21
    name: "Battery Monitor Enable"
    id: battery_monitor_enable
    restore_mode: RESTORE_DEFAULT_ON
    internal: true

  # Buzzer
  - platform: gpio
    pin:
      number: GPIO45
      mode: OUTPUT
      inverted: false
      ignore_strapping_warning: true
    id: buzzer_sw
    internal: true
    name: "Buzzer Enable"

# Buzzer Scripts
script:
  - id: beep_short
    mode: restart
    then:
      - switch.turn_on: buzzer_sw
      - delay: 200ms
      - switch.turn_off: buzzer_sw

  - id: beep_double
    mode: restart
    then:
      - switch.turn_on: buzzer_sw
      - delay: 100ms
      - switch.turn_off: buzzer_sw
      - delay: 100ms
      - switch.turn_on: buzzer_sw
      - delay: 100ms
      - switch.turn_off: buzzer_sw

# SPI Interface
spi:
  clk_pin: GPIO7
  mosi_pin: GPIO9
  miso_pin: GPIO8

# Display
display:
  - platform: epaper_spi
    id: epaper_display
    model: 7.3in-spectra-e6
    cs_pin: GPIO10
    dc_pin: GPIO11
    reset_pin:
      number: GPIO12
      inverted: false
    busy_pin:
      number: GPIO13
      inverted: true
    update_interval: 3min
    rotation: 90
    pages:
      - id: main_page
        lambda: |-
          int width = it.get_width();
          int height = it.get_height();

          const int HEADER_HEIGHT = 80;
          const int FOOTER_HEIGHT = 60;
          const int MARGIN = 20;

          // Blauer Header-Block (oben)
          it.filled_rectangle(0, 0, width, HEADER_HEIGHT, id(display_blue));

          // Uhrzeit weiÃŸ mittig zentriert im blauen Block
          it.printf(width/2, HEADER_HEIGHT/2, id(inter_large), id(display_white),
                   TextAlign::CENTER, "%s",
                   id(current_time).has_state() ? id(current_time).state.c_str() : "--:--");

          // Content-Bereich zwischen Header und Footer
          int content_start_y = HEADER_HEIGHT + MARGIN;
          int content_end_y = height - FOOTER_HEIGHT - MARGIN;
          int content_height = content_end_y - content_start_y;

          const int CARD_PADDING = 15;
          const int CARD_SPACING = 20;

          // Termine als Cards (linke Spalte)
          int card_y = content_start_y;

          if (id(calendar_events).has_state() && id(calendar_events).state.length() > 0) {
            std::string events = id(calendar_events).state;
            size_t pos = 0;
            int event_count = 0;

            while (pos < events.length() && event_count < 5 && card_y < content_end_y - 80) {
              size_t newline_pos = events.find('\n', pos);
              std::string event;

              if (newline_pos == std::string::npos) {
                event = events.substr(pos);
                pos = events.length();
              } else {
                event = events.substr(pos, newline_pos - pos);
                pos = newline_pos + 1;
              }

              // PrÃ¼fe ob Event in der Vergangenheit liegt (Prefix: â±)
              bool is_past = (event.length() > 0 && event.substr(0, 3) == "â±");

              // Entferne Prefix vom Event-Text
              std::string event_text = event;
              if (event.length() > 0 && (event.substr(0, 3) == "â±" || event.substr(0, 4) == "ðŸ“…")) {
                size_t pipe_pos = event.find('|');
                if (pipe_pos != std::string::npos) {
                  event_text = event.substr(pipe_pos + 1);
                }
              }

              // Card zeichnen mit runden Ecken
              int card_height = 60;
              int card_width = (width - 3*MARGIN) / 2;

              // WeiÃŸer oder grauer Hintergrund je nach Status
              if (is_past) {
                // Grau schraffierter Hintergrund fÃ¼r vergangene Events
                it.filled_rectangle(MARGIN, card_y, card_width, card_height, id(display_gray));
              } else {
                it.filled_rectangle(MARGIN, card_y, card_width, card_height, id(display_white));
              }

              // Grauer Rahmen
              it.rectangle(MARGIN, card_y, card_width, card_height, id(display_gray));
              it.rectangle(MARGIN+1, card_y+1, card_width-2, card_height-2, id(display_gray));

              // Event-Text (weiÃŸ bei vergangenen Events, schwarz bei zukÃ¼nftigen)
              auto text_color = is_past ? id(display_white) : id(display_black);
              it.printf(MARGIN + CARD_PADDING, card_y + card_height/2, id(inter_small), text_color,
                       TextAlign::CENTER_LEFT, "%s", event_text.c_str());

              card_y += card_height + CARD_SPACING;
              event_count++;
            }
          }

          // Einkaufsliste Card (rechte Spalte)
          int shopping_x = width / 2 + MARGIN/2;
          int shopping_card_width = (width - 3*MARGIN) / 2;
          int shopping_card_height = content_height;

          // WeiÃŸer Hintergrund
          it.filled_rectangle(shopping_x, content_start_y, shopping_card_width, shopping_card_height, id(display_white));

          // Grauer Rahmen (dicker)
          it.rectangle(shopping_x, content_start_y, shopping_card_width, shopping_card_height, id(display_gray));
          it.rectangle(shopping_x+1, content_start_y+1, shopping_card_width-2, shopping_card_height-2, id(display_gray));

          // Titel
          it.printf(shopping_x + CARD_PADDING, content_start_y + CARD_PADDING, id(inter_medium), id(display_black),
                   TextAlign::TOP_LEFT, "Einkaufsliste");

          int shopping_y = content_start_y + 50;
          if (id(shopping_list_items).has_state() && id(shopping_list_items).state.length() > 0) {
            std::string items = id(shopping_list_items).state;
            size_t pos = 0;
            int item_count = 0;

            while (pos < items.length() && item_count < 15 && shopping_y < content_end_y - 30) {
              size_t newline_pos = items.find('\n', pos);
              std::string item;

              if (newline_pos == std::string::npos) {
                item = items.substr(pos);
                pos = items.length();
              } else {
                item = items.substr(pos, newline_pos - pos);
                pos = newline_pos + 1;
              }

              it.printf(shopping_x + CARD_PADDING, shopping_y, id(inter_small), id(display_black),
                       TextAlign::TOP_LEFT, "â€¢ %s", item.c_str());
              shopping_y += 26;
              item_count++;
            }
          } else {
            it.printf(shopping_x + CARD_PADDING, shopping_y, id(inter_small), id(display_black),
                     TextAlign::TOP_LEFT, "Keine EintrÃ¤ge");
          }

          // GrÃ¼ner Footer-Block (unten)
          it.filled_rectangle(0, height - FOOTER_HEIGHT, width, FOOTER_HEIGHT, id(display_green));

          // Batterie-Status im grÃ¼nen Footer (5% vom linken Rand)
          int footer_y = height - FOOTER_HEIGHT;
          int battery_x = width * 0.05;

          // Batterie-Prozent anzeigen
          float battery = id(battery_level).has_state() ? id(battery_level).state : 0.0f;
          it.printf(battery_x, footer_y + FOOTER_HEIGHT/2, id(inter_medium), id(display_black),
                   TextAlign::CENTER_LEFT, "Akku: %.0f%%", battery);
